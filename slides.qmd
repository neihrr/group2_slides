---
title: "Fetch, async/await"
format: revealjs
---

## Asynchronous vs. Synchronous JavaScript

- **Synchronous JavaScript**  
  Operations are performed one after the other.  
  Each line of code waits for the previous one.  
  Predictable, linear order.  
  Each task is completed before the next one starts.

- **Asynchronous JavaScript**  
  Allows multiple tasks to run independently of each other.  
  Non-blocking nature of execution.  
  Improves performance and responsiveness.  
  Widely used in modern web applications.

---

## Event Loop

![Internals of Asynchronous Javascript](event_loop.png)

## How JavaScript Handles Asynchronous Code

- **Call Stack**  
  The call stack is where functions are executed in the order they’re called.  
  In synchronous operations, each function is added to the stack and executed before moving to the next.

- **Web APIs (in Browsers)**  
  Functions like `setTimeout`, HTTP requests, and event listeners are handled by Web APIs in the browser.  
  They manage the timing without blocking the main call stack.

- **Callback Queue**  
  Once the Web API has finished its job (like waiting for the timeout),  
  it pushes the callback function (like the one in `setTimeout`) to the callback queue.

- **Event Loop**  
  The event loop continuously checks the call stack.  
  If it’s empty, it pushes the functions from the callback queue onto the stack for execution.  

---

## REST APIs and JSON

**REST** (Representational state transfer): Defines certain rules the API will follow

- Each "thing" we want to send/receive is a "resource"
- Identified by a URI (path)
- Servers return "representation" of the resource
- Clients send (possibly partial) representations to update resources
- Servers are stateless, they don't "remember" clients
- Each request includes URI, user info, authorization token, etc.

## REST APIs and JSON

**JSON** (JavaScript Object Notation)

- Based on JS object syntax, but stricter
- Contains strings, numbers, true, false, null, arrays, objects
- Each property must be in the form of `"key": value`

```json
{
  "id": 1206,
  "courses": [
    { "dept": "CS", "num": "106A" },
    { *"dept": "CS"*, "num": "106A" },
   ],
   "current": true
}
```

Access: object.courses\[1\].dept

## Classes and Rest APIs

Classes can be used to model RESTful resources

- **Encapsulate** resource-related logic and data in one place
- **Reuse** methods across different instances
- **Abstract** away HTTP details from the rest of the application

```js
class Student {
  constructor(data) {
    Object.assign(this, data); // Initialize properties
  }

  static async load(id) {
    const response = await fetch(`/api/students/${id}`);
    const data = await response.json();
    return new Student(data);
  }
}
```

---
---
title: "Asynchronous Class Instance Initialization"
format: revealjs
author: Javad Sheikhimofrad
---

## Why async static methods?

- In JavaScript, constructors can't be async.
- If you need to fetch data from a server before creating an instance, use a static async method.
- The static method fetches data asynchronously, then creates and returns an instance.

---

## Example Pattern

```js
class User {
  constructor(data) {
    Object.assign(this, data);
  }
  static async load(id) {
    let res = await fetch(`/api/users/${id}`);
    let data = await res.json();
    return new User(data);
  }
}

// Usage:
let user = await User.load("ali");
console.log(user);
```

---

## In Our Project

```js
static async load(id) {
  let res = await fetch(`/api/students/${id}`);
  let data = await res.json();
  return new Student(data);
}
```
